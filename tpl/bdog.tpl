// Generated by {{.Username}} on {{.Timestamp}}
// using http://github.com/pbnjay/bdog
//
// AUTO-GENERATED CODE! DO NOT EDIT!
// Place your additions in a separate file within the same package to avoid overwriting.
//
// AUTO-GENERATED CODE! DO NOT EDIT!

package {{.PackageName}}

import (
  "database/sql"
  "fmt"
  _ "github.com/lib/pq"
{{range .OtherImports}}  "{{.}}"
{{end}}
)

var ( Db *sql.DB )

{{range .Tables}}

type {{.StructName}} struct { {{range .StructFields}}
    {{.GoName}} {{.GoType}} `dbc:"{{.DBName}}" dbt:"{{.DBType}}"{{if .DBDefault}} dbd:"{{.DBDefault}}"{{end}}{{if .DBAutoInc}} dbautoinc:"yes"{{end}}`{{end}}
}

func listOf{{.StructName}}(rows *sql.Rows) ([]*{{.StructName}}, error) {
    {{$StructName := print "new" .StructName}}
    {{.V}} := []*{{.StructName}}{}
    for rows.Next() {
        {{range .StructFields}}{{if .ScanName}}  var {{.ScanName}} {{.ScanType}}
        {{end}}{{end}}

        new{{.StructName}} := &{{.StructName}}{}
        err := rows.Scan(
            {{range .StructFieldsOrder}}  &{{if .ScanName}}{{.ScanName}}{{else}}{{$StructName}}.{{.GoName}}{{end}},
            {{end}}
        )
        if err != nil {
            return nil,err
        }

        {{range .StructFields}}{{if .ScanName}}{{.ParseCode $StructName}}
        {{end}}{{end}}

        {{.V}} = append({{.V}}, new{{.StructName}})
    }
    if err := rows.Err(); err != nil {
        return nil, err
    }
    return {{.V}}, nil
}

func Fetch{{.StructName}}({{.VarsTypesPK}}) (*{{.StructName}}, error) {
    SQL := "select {{.Cols}} from {{.TableRef}} where {{.WherePK}}"
    rows, err := Db.Query(SQL, {{.VarsPK}})

    if err != nil {
        return nil,err
    }
    res, err := listOf{{.StructName}}(rows)
    if err!=nil || len(res)==0 {
        return nil,err
    }
    return res[0],nil
}

func All{{.PluralName}}Where(wheresql string, whereargs ...interface{}) ([]*{{.StructName}}, error) {
    SQL := "select {{.Cols}} from {{.TableRef}}"
    var rows *sql.Rows
    var err error

    if wheresql=="" {
        rows, err = Db.Query(SQL)
    } else {
        rows, err = Db.Query(SQL+" where "+wheresql, whereargs...)
    }
    if err != nil {
        return nil,err
    }
    return listOf{{.StructName}}(rows)
}

func All{{.PluralName}}() ([]*{{.StructName}}, error) {
    return All{{.PluralName}}Where("")
}

func ({{.V}} *{{.StructName}}) Update() error {
    SQL := "update {{.TableRef}} set {{.UpdateCols}} where {{.WherePK}}"

    res, err := Db.Exec(SQL, {{.FieldsPK}}, {{.UpdateFields}})
    if err!=nil {
        return err
    }

    nup, err := res.RowsAffected()
    if nup!=1 {
        return fmt.Errorf("Nothing updated (%d). DB Contents changed?", nup)
    }
    return err
}

func ({{.V}} *{{.StructName}}) Delete() error {
    SQL := "delete from {{.TableRef}} where {{.WherePK}}"

    res, err := Db.Exec(SQL, {{.FieldsPK}})
    if err!=nil {
        return err
    }

    nup, err := res.RowsAffected()
    if nup!=1 {
        return fmt.Errorf("Nothing deleted (%d). Already gone?", nup)
    }
    return err
}

func ({{.V}} *{{.StructName}}) Insert() error {
    SQL := "insert into {{.TableRef}} ({{.Cols}}) values ({{.InsertPlaceholders}})"

    res, err := Db.Exec(SQL, {{.Fields}})
    if err!=nil {
        return err
    }

    nup, err := res.RowsAffected()
    if nup!=1 {
        return fmt.Errorf("Nothing inserted (%d). How did that happen without an error?", nup)
    }
    return err
}

{{end}}




{{range .Joins}}

func ({{.Base.V}} *{{.Base.StructName}}) Get{{.Other.StructName}}() (*{{.Other.StructName}}, error) {
    SQL := "select {{.Other.Cols}} from {{.Other.TableRef}} where {{.Other.WherePK}}"

    rows, err := Db.Query(SQL, {{.FieldsFK}})
    if err != nil {
        return nil,err
    }
    res, err := listOf{{.Other.StructName}}(rows)
    if err!=nil || len(res)==0 {
        return nil, err
    }
    return res[0], nil
}

func ({{.Other.V}} *{{.Other.StructName}}) Get{{.Base.StructName}}List() ([]*{{.Base.StructName}}, error) {
    SQL := "select {{.Base.Cols}} from {{.Base.TableRef}} where {{.WhereFK}}"

    rows, err := Db.Query(SQL, {{.Other.FieldsPK}})
    if err != nil {
        return nil,err
    }
    return listOf{{.Base.StructName}}(rows)
}

{{end}}
